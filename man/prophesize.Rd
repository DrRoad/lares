% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecasting.R
\name{prophesize}
\alias{prophesize}
\title{####################################################################
#' Machine Learning Forecast
#' 
#' This function lets the user create a forecast setting a time series
#' and a numerical value.
#' 
#' @family Forecast
#' @param time POSIX. Vector with dates or time values
#' @param values Numeric. Vector with numerical values
#' @param n_future Integer. How many steps do you wish to forecast?
#' @param use_last Boolean. Use last observation?
#' @param automl Boolean. Use lares::h2o_automl()
#' @param plot_forecast Boolean. If you wish to plot your results
#' @param plot_model Boolean. If you wish to plot your model's results
#' @param project Character. Name of your forecast project for plot title
#' @export
forecast_ml <- function(time, values, 
                        n_future = 15, 
                        use_last = TRUE, 
                        automl = FALSE, 
                        plot_forecast = TRUE, 
                        plot_model = FALSE,
                        project = "Simple Forecast using Machine Learning") {
  
  # require(timetk)
  # require(tidyquant)
  
  if (length(time) != length(values)) {
    stop("The parameters 'time' and 'values' should have the same length")
  }
  
  df <- data.frame(time = time, amount = values)
  if (use_last == FALSE) {
    df <- arrange(df, desc(.data$time)) %>% slice(-1)
    n_future <- n_future + 1
  }
  
  # STEP 1: AUGMENT TIME SERIES SIGNATURE
  augmented <- tk_augment_timeseries_signature(df)
  augmented <- mutate(augmented, 
                      month.lbl = as.character(.data$month.lbl),
                      wday.lbl = as.character(.data$wday.lbl))
  
  # STEP 2: BUILD FUTURE (NEW) DATA
  idx <- tk_index(augmented)
  future_idx <- tk_make_future_timeseries(idx, n_future = n_future)
  new_data_tbl <- tk_get_timeseries_signature(future_idx) %>%
    mutate(month.lbl = as.character(month.lbl),
           wday.lbl = as.character(wday.lbl))
  
  # STEP 3: MODEL
  if (!automl) {
    fit_lm <- lm(amount ~ ., data = select(augmented, -c(time)))
    pred <- predict(fit_lm, newdata = select(new_data_tbl, -c(index)))
    predictions_tbl <- tibble(time = future_idx, amount = pred) 
  } else {
    augmented_h2o <- dplyr::rename(augmented, tag = amount)
    fit_auto <- h2o_automl(df = augmented_h2o, alarm = FALSE, project = project)
    pred <- h2o.predict(fit_auto$model, as.h2o(new_data_tbl))
    predictions_tbl <- tibble(time = future_idx, amount = as.vector(pred))
  }
  
  # STEP 5: COMPARE ACTUAL VS PREDICTIONS
  rects <- data.frame(start = min(future_idx), end = max(future_idx))
  message("Predicted range: ", rects$start, " to ", rects$end)
  forecast <- ggplot(df, aes(x = time, y = amount)) + 
    labs(title = project, y = "Amount", x = NULL,
         subtitle = "Using simple multivariate regressions on time series with Machine Learning") +
    # Training data
    geom_line(color = palette_light()[[1]]) +
    geom_point(color = palette_light()[[1]]) +
    geom_smooth(method = 'loess', formula = 'y ~ x', alpha = 0.5) +
    # Predictions
    geom_line(aes(y = amount), color = palette_light()[[2]], data = predictions_tbl) +
    geom_point(aes(y = amount), color = palette_light()[[2]], data = predictions_tbl) +
    # Actuals
    geom_line(color = palette_light()[[1]], data = df) +
    geom_point(color = palette_light()[[1]], data = df) +
    # Aesthetics
    scale_x_date(date_breaks = "1 month", date_labels = "%b") +
    theme_lares2() + 
    geom_rect(data = rects, inherit.aes = FALSE, 
              aes(
                xmin = start, xmax = end, ymin = 0,
                ymax = max(df$amount) * 1.02), 
              color = "transparent", fill = "orange", alpha = 0.3)
  
  if (plot_forecast) {
    print(forecast)
  }
  
  if (plot_model) {
    Sys.sleep(1)
    mplot_full(
      tag = df$amount, 
      score = predictions_tbl$amount[1:length(df$amount)],
      subtitle = project)
    Sys.sleep(4)
  }
  
  df_final <- rbind(df, predictions_tbl)
  
  if (automl) {
    model <- fit_auto
    score <- fit_auto$scores$score
  } else {
    model <- fit_lm
    score <- fit_lm$fitted.values
  }
  
  output <- list(data = df_final, 
                 model = model, 
                 errors = errors(df$amount, score))
  
  return(output)
  
}  
Facebook's Prophet Forecast}
\usage{
prophesize(
  df,
  n_future = 60,
  country = "AR",
  trend.param = 0.05,
  logged = FALSE,
  pout = 0.03,
  project = "Prophet Forecast"
)
}
\arguments{
\item{df}{Data frame. Must contain date/time column and values column}

\item{n_future}{Integer. How many steps do you wish to forecast?}

\item{country}{Character. Country code for holidays}

\item{trend.param}{Numeric. Flexibility of trend component. Default is 0.05, 
and as this value becomes larger, the trend component will be more flexible.}

\item{logged}{Boolean. Convert values into logs?}

\item{pout}{Numeric. Get rid of pout \% of outliers}

\item{project}{Character. Name of your forecast project for plot title}
}
\description{
Prophet is Facebook's procedure for forecasting time series data 
based on an additive model where non-linear trends are fit with 
yearly, weekly, and daily seasonality, plus holiday effects. It 
works best with time series that have strong seasonal effects and 
several seasons of historical data. Prophet is robust to missing 
data and shifts in the trend, and typically handles outliers well.
}
\details{
Official documentation: \url{https://github.com/facebook/prophet}
}
\seealso{
Other Forecast: 
\code{\link{forecast_arima}()}
}
\concept{Forecast}
